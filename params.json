{"name":"Algoblog","tagline":"This repo conntains some basic data structures and algorithmic questions for practice; All the questions with the solutions can be found posted on my blog;","body":"# algoBlog\r\nThis repo conntains some basic data structures and algorithmic questions for practice; All the questions with the solutions can be found posted on my blog;\r\n\r\n*******************\r\n###\tproblem-1\r\n*******************\r\n_####Find the 'k'th node from end of linkedlist;\t\r\n\r\n\r\n*******************\r\n###\tproblem-2\r\n*******************\r\n__####Given only a pointer to a node to be deleted in a singly linked list, how do you delete it?\r\nA simple solution is to traverse the linked list until you find the node you want to delete. \r\nBut this solution requires pointer to the head node which contradicts the problem statement.\r\n\r\nFast solution is to copy the data from the next node to the node to be deleted and delete the next node;\r\nCaution: This solution doesn’t work if the node to be deleted is the last node of the list. \r\nTo make this solution work we can mark the end node as a dummy node.(No other option known till I code this)\r\n\r\n\r\n\r\n*******************\r\n###\tproblem-3\r\n*******************\r\n__####Write a function to print the middle of a given linked list\r\n\r\n***\r\nMethod 1:\r\nTraverse the whole linked list and count the no. of nodes. \r\nNow traverse the list again till count/2 and return the node at count/2.\r\n\r\n***\r\nMethod 2:\r\nTraverse linked list using two pointers. Move one pointer by one and other pointer by two. \r\nWhen the fast pointer reaches end slow pointer will reach middle of the linked list.\r\n\r\n\r\n\r\n*******************\r\n###\tproblem-4\r\n*******************\r\n__####Write a function that counts the number of times a given item occurs in a Linked List\r\nHere is a solution.\r\n\r\nAlgorithm:\r\n1. Initialize count as zero.\r\n2. Loop through each element of linked list:\r\n     a) If element data is equal to the key item then\r\n        increment the count.\r\n3. Return count. \r\n \r\n \r\n \r\n*******************\r\n\tproblem-5\r\n*******************\r\nWrite a function to reverse a linked list\r\n\r\n1) Iterative Method\r\nIterate trough the linked list. In loop, change next to prev, prev to current and current to next.\r\n\r\n2) Recursive Method:\r\nhttps://www.youtube.com/watch?v=KYH83T4q6Vs\r\nThe cool thing about recursion in this problem is that it essentially allows us to iterate through \r\nthe linked list backwards – even though this is impossible in a singly linked list just by using the pointers \r\n(of course this would certainly be possible in a doubly linked list). \r\nThe reason we can do this in recursion is because of the fact that the stack frames for each function call \r\nare saved until we get to the very end of the list, and then it is as if we are ‘unwinding’ the stack frames one by one going backwards in the linked list – where each stack frame essentially represents a node in the linked list. \r\nMake sure you understand this point, because it is important and really helps in your \r\nunderstanding of how to use recursion to solve problems.\r\n\r\n\r\n\r\n*******************\r\n\tproblem-6\r\n*******************\r\nWrite a function to detect loop in a linked list\r\n\r\nFollowing are different ways of doing this\r\n1) Use Hashing:(Extra Space Needed)\r\nTraverse the list one by one and keep putting the node addresses in a Hash Table. \r\nAt any point, if NULL is reached then return false and if next of current node points \r\nto any of the previously stored nodes in Hash then return true.\r\n\r\n2) Mark Visited Nodes:(Data Structure needs to be changed)\r\nThis solution requires modifications to basic linked list data structure.  Have a visited flag with each node.  Traverse the linked list and keep marking visited nodes.  If you see a visited node again then there is a loop. This solution works in O(n) but requires additional information with each node.\r\nA variation of this solution that doesn’t require modification to basic data structure can be implemented using hash.  Just store the addresses of visited nodes in a hash and if you see an address that already exists in hash then there is a loop.\r\n\r\n3) Floyd’s cycle detection algorithm\r\nThe Tortoise (Slow ptr) and the Hare (fast ptr) start at the beginning of linked list.\r\nFor each iteration, slow ptr moves one step and the fast ptr moves two steps.\r\nIf there is a loop, fast ptr will go around the loop and meet with slow ptr.\r\nIf there is no loop, the fast prt will get to the end of the list without meeting up with the slow ptr.\r\n\r\nSize-of-loop: start the slow ptr again from the current position(one step at a time) until it reaches the current position gain after completing the loop;\r\nWhile moving kepp the counter for counting the number of loops encountered, this counter will give the size of loop;\r\n\r\nStarting point of loop: Set the slow ptr from start and fast ptr from its current position , move them both one step at a time now, until they\r\nmeet at a position, this meeting point will give you the start of the loop;\r\nCorrectness of algorithm for finding start node of loop:\r\nLets assume that linked list has a “non-looped” part of size k. \r\nWhen we apply Floyd’s cycle detection algorithm, we know that after k steps,\r\n--slowPtr will be at start of loop, and is 0 steps into the loop.\r\n--fastPtr is k steps into the loop. since k might be much larger than loop_size,it is actually k%loop_size. Let’s say it as p. So fastPtr is p steps into the loop.\r\n--slowPtr is p steps behind fastPtr.\r\n--fastPtr is loop_size – p steps behind slowPtr.\r\n--fastPtr catches up to slowPtr at a rate of one step per unit of time.\r\nFrom above points, after loop_size – p steps, fastPtr and slowPtr meet each other, which means they will be p steps before start of the loop.\r\nSince p = k%loop_size ( k = p+M*loop_size), it is correct to say that, fastPtr, slowPtr are k steps from start node of the loop.\r\nIf we reinitialise slowPtr to head node and start moving both pointers one node at a time. they both meet at start node of the loop.\r\n\r\nPrinting the loop(trivial): starting from the starting point of the loop , move one step at a time equal to size-of-loop; While moving \r\nkeep on printing the the nodes, this will give you all the  nodes in cycle;\r\n\r\n4)Brent’s Cycle detection Algorithm\r\nThis algorithm is based on Floyd‘s algorithm. It is more efficient (24-36% faster on average) than Floyd‘s but little complicated.\r\n\r\nStart ptr1 (Moving ptr), ptr2 (Stationary pointer) from beginning of the list\r\nptr1 takes one step per iteration, If it is then at the same position as the ptr2, there is obviously a loop. If it reaches the end of the list, there is no loop.\r\nTeleport ptr2 position to ptr1 position occasionally. We start out waiting just 2 steps before teleportation, and we double that each time we move the ptr2.\r\n\r\n\r\n\r\n*******************\r\n\tproblem-7\r\n*******************\r\nWrite a function to get the intersection point of two Linked Lists.\r\nThere are two singly linked lists in a system. By some programming error the end node of one of the linked list got linked into the second list, forming a inverted Y shaped list. Write a program to get the point where two linked list merge.\r\n\r\n\r\nMethod 1(Simply use two loops)\r\nUse 2 nested for loops. \r\nOuter loop will be for each node of the 1st list and inner loop will be for 2nd list. \r\nIn the inner loop, check if any of nodes of 2nd list is same as the current node of first linked list. \r\nTime complexity of this method will be O(m*n) where m and n are the number of nodes in two lists.\r\n\r\n\r\nMethod 2 (Mark Visited Nodes)\r\nThis solution requires modifications to basic linked list data structure. \r\nHave a visited flag with each node. \r\nTraverse the first linked list and keep marking visited nodes. \r\nNow traverse second linked list, \r\nIf you see a visited node again then there is an intersection point, return the intersecting node. \r\nThis solution works in O(m+n) but requires additional information with each node. \r\n\r\n\r\n\r\nMethod 3( Hash based data structure)\r\nA variation of the above solution that doesn’t require modification to basic data structure can be implemented using hash. \r\nTraverse the first linked list and store the addresses of visited nodes in a hash. \r\nNow traverse the second linked list and if you see an address that already exists in hash then return the intersecting node.\r\nTime complexity is O(m+n) but requires additional space equal O(N) or O(M)\r\n\r\n\r\n\r\nMethod 4(Using difference of node counts)\r\n\t1) Get count of the nodes in first list, let count be c1.\r\n\t2) Get count of the nodes in second list, let count be c2.\r\n\t3) Get the difference of counts d = abs(c1 – c2)\r\n\t4) Now traverse the bigger list from the first node till d nodes so that from here onwards both the lists have equal no of nodes.\r\n\t5) Then we can traverse both the lists in parallel till we come across a common node. \r\n\t(Note that getting a common node is done by comparing the address of the nodes)\r\n\r\n\r\n\r\nMethod 5(Make circle in first list)\r\n\t1. Traverse the first linked list(count the elements) and make a circular linked list. \r\n\t(Remember last node so that we can break the circle later on).\r\n\t2. Now view the problem as find the loop in the second linked list. So the problem is solved.\r\n\t3. Since we already know the length of the loop(size of first linked list) we can traverse those many number of nodes in second list, and then start another pointer from the beginning of second list. we have to traverse until they are equal, and that is the required intersection point.\r\n\t4. remove the circle from the linked list.\r\nTime Complexity: O(m+n)\r\nAuxiliary Space: O(1)\t\r\n\r\n\r\n\r\nMethod 6 (Reverse the first list and make equations)\r\n1) Let X be the length of the first linked list until intersection point.\r\n   Let Y be the length of the second linked list until the intersection point.\r\n   Let Z be the length of the linked list from intersection point to End of\r\n   the linked list including the intersection node.\r\n   We Have\r\n           X + Z = C1;\r\n           Y + Z = C2;\r\n2) Reverse first linked list.\r\n3) Traverse Second linked list. Let C3 be the length of second list - 1. \r\n     Now we have\r\n        X + Y = C3\r\n     We have 3 linear equations. By solving them, we get\r\n       X = (C1 + C3 – C2)/2;\r\n       Y = (C2 + C3 – C1)/2;\r\n       Z = (C1 + C2 – C3)/2;\r\n      WE GOT THE INTERSECTION POINT.\r\n4)  Reverse first linked list.\r\nAdvantage: No Comparison of pointers.\r\nDisadvantage : Modifying linked list(Reversing list).\r\n\r\nTime complexity: O(m+n)\r\nAuxiliary Space: O(1)\r\n\r\n\r\n\r\nMethod 7: Method To Detect if there is an intersection in list or Not\r\n(Traverse both lists and compare addresses of last nodes) \r\nThis method is only to detect if there is an intersection point or not.\r\n1) Traverse the list 1, store the last node address.\r\n2) Traverse the list 2, store the last node address.\r\n3) If nodes stored in 1 and 2 are same then they are intersecting.\r\nTime complexity of this method is O(m+n) and used Auxiliary space is O(1)\r\n\r\n\r\n\r\n*******************\r\n\tproblem-8\r\n*******************\r\nFunction to check if a singly linked list is palindrome\r\nGiven a singly linked list of characters, write a function that returns true if the given list is palindrome, else false.\r\n\r\n\r\nMETHOD 1: Use a Stack\r\nA simple solution is to use a stack of list nodes. This mainly involves three steps.\r\n1) Traverse the given list from head to tail and push every visited node to stack.\r\n2) Traverse the list again. For every visited node, pop a node from stack and compare data of popped node with currently visited node.\r\n3) If all nodes matched, then return true, else false.\r\nTime complexity of above method is O(n), but it requires O(n) extra space. Following methods solve this with constant extra space.\r\n\r\n\r\nMETHOD 2: By reversing the list\r\nThis method takes O(n) time and O(1) extra space.\r\n1) Get the middle of the linked list.\r\n2) Reverse the second half of the linked list.\r\n3) Check if the first half and second half are identical.\r\n4) Construct the original linked list by reversing the second half again and attaching it back to the first half\r\n\r\nTo divide the list in two halves.\r\nWhen number of nodes are even, the first and second half contain exactly half nodes. \r\nThe challenging thing in this method is to handle the case when number of nodes are odd. \r\nWe don’t want the middle node as part of any of the lists as we are going to compare them for equality. \r\nFor odd case, we use a separate variable ‘midnode’.\r\n\t\r\n\r\n\r\nMETHOD 3: Using Recursion\r\nUse two pointers left and right. Move right and left using recursion and check for following in each recursive call.\r\n1) Sub-list is palindrome.\r\n2) Value at current left and right are matching.\r\n\r\nIf both above conditions are true then return true.\r\nThe idea is to use function call stack as container. \r\nRecursively traverse till the end of list. When we return from last NULL, we will be at last node. \r\nThe last node to be compared with first node of list.\r\nIn order to access first node of list, we need list head to be available in the last call of recursion. \r\nHence we pass head also to the recursive function. If they both match we need to compare (2, n-2) nodes. \r\nAgain when recursion falls back to (n-2)nd node, we need reference to 2nd node from head. \r\nWe advance the head pointer in previous call, to refer to next node in the list.\r\nHowever, the trick in identifying double pointer. \r\nPassing single pointer is as good as pass-by-value, and we will pass the same pointer again and again. \r\nWe need to pass the address of head pointer for reflecting the changes in parent recursive calls.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}