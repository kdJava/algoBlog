{"name":"Algorithmist's Blog::Always learning !!!","tagline":"This repo conntains some basic data structures and algorithmic questions for practice; All the questions with the solutions can be found posted on my blog;","body":"# Algorithmist's Blog : Always learning !!!\r\nLets See..!!\t<<http://kdjava.github.io/algoBlog>>\r\n>This repo conntains some basic data structures and algorithmic questions for practice; All the questions with the solutions can be found posted on my blog;\r\n\r\n*******************\r\n####\tproblem-1: Find the 'k'th node from end of linkedlist;\r\n*******************\r\n\t\r\n\r\n\r\n*******************\r\n####\tproblem-2: Given only a pointer to a node to be deleted in a singly linked list, how do you delete it?\r\n*******************\r\nA simple solution is to traverse the linked list until you find the node you want to delete. \r\nBut this solution requires pointer to the head node which contradicts the problem statement.\r\n\r\nFast solution is to copy the data from the next node to the node to be deleted and delete the next node;\r\nCaution: This solution doesn’t work if the node to be deleted is the last node of the list. \r\nTo make this solution work we can mark the end node as a dummy node.(No other option known till I code this)\r\n\r\n\r\n\r\n*******************\r\n####\tproblem-3: Write a function to print the middle of a given linked list\r\n*******************\r\n**Method 1**: Traverse the whole linked list and count the no. of nodes Now traverse the list again till count/2 and return the node at count/2.  \r\n**Method 2**:Traverse linked list using two pointers. Move one pointer by one and other pointer by two. \r\nWhen the fast pointer reaches end slow pointer will reach middle of the linked list.  \r\n\r\n\r\n\r\n*******************\r\n####\tproblem-4: Write a function that counts the number of times a given item occurs in a Linked List\r\n*******************\r\nHere is a solution:  \r\n\r\n#####\tAlgorithm:  \r\n\r\n\t1. Initialize count as zero.  \r\n\t2. Loop through each element of linked list:\r\n     \tIf element data is equal to the key item then\r\n        increment the count, continue the loop;\r\n\t3. Return count. \r\n \r\n \r\n \r\n*******************\r\n####\tproblem-5: Write a function to reverse a linked list\r\n*******************\r\n######1. Iterative Method\r\nIterate trough the linked list. In loop, change next to prev, prev to current and current to next.\r\n\r\n######2. Recursive Method:\r\nhttps://www.youtube.com/watch?v=KYH83T4q6Vs\r\nThe cool thing about recursion in this problem is that it essentially allows us to iterate through \r\nthe linked list backwards – even though this is impossible in a singly linked list just by using the pointers \r\n(of course this would certainly be possible in a doubly linked list). \r\nThe reason we can do this in recursion is because of the fact that the stack frames for each function call \r\nare saved until we get to the very end of the list, and then it is as if we are ‘unwinding’ the stack frames one by one going backwards in the linked list – where each stack frame essentially represents a node in the linked list. \r\nMake sure you understand this point, because it is important and really helps in your \r\nunderstanding of how to use recursion to solve problems.\r\n\r\n\r\n\r\n*******************\r\n####\tproblem-6: Write a function to detect loop in a linked list\r\n*******************\r\nFollowing are different ways of doing this:  \r\n\r\n######\tMethod 1. Use Hashing:(Extra Space Needed)  \r\n\r\nTraverse the list one by one and keep putting the node addresses in a Hash Table. \r\nAt any point, if NULL is reached then return false and if next of current node points \r\nto any of the previously stored nodes in Hash then return true.\r\n\r\n\r\n######\tMethod 2. Mark Visited Nodes:(Data Structure needs to be changed)  \r\n\r\nThis solution requires modifications to basic linked list data structure.  Have a visited flag with each node.  Traverse the linked list and keep marking visited nodes.  If you see a visited node again then there is a loop. This solution works in O(n) but requires additional information with each node.\r\nA variation of this solution that doesn’t require modification to basic data structure can be implemented using hash.  Just store the addresses of visited nodes in a hash and if you see an address that already exists in hash then there is a loop.\r\n\r\n\r\n######\tMethod 3. Floyd’s cycle detection algorithm  \r\n\r\nThe Tortoise (Slow ptr) and the Hare (fast ptr) start at the beginning of linked list.\r\nFor each iteration, slow ptr moves one step and the fast ptr moves two steps.\r\nIf there is a loop, fast ptr will go around the loop and meet with slow ptr.\r\nIf there is no loop, the fast prt will get to the end of the list without meeting up with the slow ptr.  \r\n\r\n\r\n**Size-of-loop**: start the slow ptr again from the current position(one step at a time) until it reaches the current position gain after completing the loop; While moving kepp the counter for counting the number of loops encountered, this counter will give the size of loop;  \r\n\r\n\r\n**Starting point of loop**: Set the slow ptr from start and fast ptr from its current position , move them both one step at a time now, until they meet at a position, this meeting point will give you the start of the loop;  \r\n\t  \r\n\t  \r\n**Correctness of algorithm for finding start node of loop:**  \r\n*Lets assume that linked list has a `non-looped` part of size k.*  \r\n*When we apply Floyd’s cycle detection algorithm, we know that after k steps,*  \r\n\r\n-`slowPtr will be at start of loop, and is 0 steps into the loop.`  \r\n\r\n-`fastPtr is k steps into the loop. since k might be much larger than loop_size,`  \r\n-`it is actually *k%loop_size*. Let’s say it as p. So fastPtr is p steps into the loop.`  \r\n\r\n-`slowPtr is p steps behind fastPtr`  \r\n\r\n-`fastPtr is *(loop_size – p)* steps behind slowPtr`  \r\n\r\n-`fastPtr catches up to slowPtr at a rate of one step per unit of time`  \r\n\r\n-`From above points, after *(loop_size – p)* steps, fastPtr and slowPtr meet each other, which means they will be p steps before start of the loop.`  \r\n-`Since *p = k%loop_size ( k = p+M*loop_size)*, it is correct to say that, fastPtr, slowPtr are k steps from start node of the loop.` \r\n-`If we reinitialise slowPtr to head node and start moving both pointers one node at a time. they both meet at start node of the loop.`  \r\n\r\n**Printing the loop(trivial)**\r\n* Starting from the starting point of the loop , move one step at a time equal to size-of-loop; While moving \r\nkeep on printing the the nodes, this will give you all the  nodes in cycle;*  \r\n\r\n\r\n######\tMethod 4. Brent’s Cycle detection Algorithm  \r\n\t\r\nThis algorithm is based on Floyd‘s algorithm. It is more efficient (24-36% faster on average) than Floyd‘s but little complicated.  \r\n\r\n1. Start ptr1 (Moving ptr), ptr2 (Stationary pointer) from beginning of the list  \r\n\r\n2. ptr1 takes one step per iteration, If it is then at the same position as the ptr2, there is obviously a loop. If it reaches the end of the list, there is no loop.  \r\n\r\n3. Teleport ptr2 position to ptr1 position occasionally. We start out waiting just 2 steps before teleportation, and we double that each time we move the ptr2.  \r\n\r\n\r\n\r\n*******************\r\n####\tproblem-7: Write a function to get the intersection point of two Linked Lists.\r\n*******************\r\nThere are two singly linked lists in a system. By some programming error the end node of one of the linked list got linked into the second list, forming a inverted Y shaped list. Write a program to get the point where two linked list merge.\r\n\r\n\r\n######\tMethod 1. Simply use two loops\r\nUse 2 nested for loops. \r\n-Outer loop will be for each node of the 1st list and inner loop will be for 2nd list. \r\n-In the inner loop, check if any of nodes of 2nd list is same as the current node of first linked list. \r\n**Time complexity of this method will be O(m*n) where m and n are the number of nodes in two lists.**\r\n\r\n\r\n \r\n######\tMethod 2. Mark Visited Nodes\r\nThis solution requires modifications to basic linked list data structure. \r\n-Have a visited flag with each node. \r\n-Traverse the first linked list and keep marking visited nodes. \r\n-Now traverse second linked list, \r\n-If you see a visited node again then there is an intersection point, return the intersecting node.  \r\n\r\n-*This solution works in O(m+n) but requires additional information with each node.* \r\n\r\n\r\n\r\n######\tMethod 3. Hash based data structure\r\nA variation of the above solution that doesn’t require modification to basic data structure can be implemented using hash. \r\n\r\n-Traverse the first linked list and store the addresses of visited nodes in a hash.  \r\n\r\n-Now traverse the second linked list and if you see an address that already exists in hash then return the intersecting node.  \r\n\r\n-*Time complexity is O(m+n) but requires additional space equal O(N) or O(M).*  \r\n\r\n\r\n\r\n######\tMethod 4. Using difference of node counts\r\n\t1) Get count of the nodes in first list, let count be c1.\r\n\t2) Get count of the nodes in second list, let count be c2.\r\n\t3) Get the difference of counts d = abs(c1 – c2).\r\n\t4) Now traverse the bigger list from the first node till d nodes so that from here onwards both the lists have equal no of nodes.\r\n\t5) Then we can traverse both the lists in parallel till we come across a common node. \r\n\t*(Note that getting a common node is done by comparing the address of the nodes).*\r\n\r\n\r\n\r\n######\tMethod 5. Make circle in first list\r\n\t1. Traverse the first linked list(count the elements) and make a circular linked list. \r\n\t   (Remember last node so that we can break the circle later on).\r\n\t2. Now view the problem as find the loop in the second linked list. So the problem is solved.\r\n\t3. Since we already know the length of the loop(size of first linked list) we can traverse those many number of nodes in second list, and then start another pointer from the beginning of second list. we have to traverse until they are equal, and that is the required intersection point.\r\n\t4. remove the circle from the linked list.\r\n**Time Complexity: O(m+n)**\r\n**Auxiliary Space: O(1)**\t\r\n\r\n\r\n\r\n######\tMethod 6. Reverse the first list and make equations\r\n1. Let X be the length of the first linked list until intersection point.\r\n   Let Y be the length of the second linked list until the intersection point.\r\n   Let Z be the length of the linked list from intersection point to End of\r\n   the linked list including the intersection node.\r\n   We Have  \r\n   \t`X + Z = C1;`  \r\n   \t`Y + Z = C2;`\r\n2. Reverse first linked list.\r\n3. Traverse Second linked list. Let C3 be the length of second list - 1.  \r\n   Now we have  \r\n\r\n        \t`X + Y = C3`  \r\n        \r\n     We have 3 linear equations. By solving them, we get  \r\n     \r\n       \t`X = (C1 + C3 – C2)/2;`  \r\n       \t`Y = (C2 + C3 – C1)/2;`  \r\n       \t`Z = (C1 + C2 – C3)/2;`  \r\n       \t\r\n      *WE GOT THE INTERSECTION POINT.*\r\n4.  Reverse first linked list.\r\n*Advantage: No Comparison of pointers.*\r\n*Disadvantage : Modifying linked list(Reversing list).*\r\n\r\n**Time complexity: O(m+n)**\r\n**Auxiliary Space: O(1)**\r\n\r\n\r\n\r\n######\tMethod 7. Method To Detect if there is an intersection in list or Not\r\n*Traverse both lists and compare addresses of last nodes* \r\n**This method is only to detect if there is an intersection point or not.**  \r\n\r\n- Traverse the list 1, store the last node address.\r\n- Traverse the list 2, store the last node address.\r\n- If nodes stored in 1 and 2 are same then they are intersecting.  \r\n\r\n*Time complexity of this method is O(m+n) and used Auxiliary space is O(1)*\r\n\r\n\r\n\r\n*******************\r\n####\tproblem-8: Function to check if a singly linked list is palindrome\r\n*******************\r\nGiven a singly linked list of characters, write a function that returns true if the given list is palindrome, else false.\r\n\r\n######\tMETHOD 1: Use a Stack\r\nA simple solution is to use a stack of list nodes. This mainly involves three steps.\r\n1) Traverse the given list from head to tail and push every visited node to stack.\r\n2) Traverse the list again. For every visited node, pop a node from stack and compare data of popped node with currently visited node.\r\n3) If all nodes matched, then return true, else false.\r\n**Time complexity of above method is O(n), but it requires O(n) extra space. Following methods solve this with constant extra space.**\r\n\r\n\r\n\r\n######\tMETHOD 2: By reversing the list\r\n*This method takes O(n) time and O(1) extra space.*  \r\n\r\n- Get the middle of the linked list.\r\n- Reverse the second half of the linked list.\r\n- Check if the first half and second half are identical.\r\n- Construct the original linked list by reversing the second half again and attaching it back to the first half.  \r\n  \r\n\r\n**To divide the list in two halves**  \r\n\r\n*When number of nodes are even, the first and second half contain exactly half nodes.*  \r\n*The challenging thing in this method is to handle the case when number of nodes are odd.*  \r\n*We don’t want the middle node as part of any of the lists as we are going to compare them for equality.*  \r\n*For odd case, we use a separate variable ‘midnode’.*  \r\n\r\n\t\r\n\r\n\r\n######\tMETHOD 3: Using Recursion\r\n*Use two pointers left and right. Move right and left using recursion and check for following in each recursive call.*\r\n\t- Sub-list is palindrome.\r\n\t- Value at current left and right are matching.\r\n\r\n\r\n+ *If both the above conditions are true then return true.*\r\n+ *The idea is to use function call stack as container.*\r\n+ *Recursively traverse till the end of list.*\r\n+ *When we return from last NULL, we will be at last node.*\r\n+ *The last node to be compared with first node of list.*\r\n+ *In order to access first node of list, we need list head to be available in the last call of recursion.* \r\n+ *Hence we pass head also to the recursive function. If they both match we need to compare (2, n-2) nodes.* \r\n+ *Again when recursion falls back to (n-2)nd node, we need reference to 2nd node from head.* \r\n+ *We advance the head pointer in previous call, to refer to next node in the list.*   \r\n\r\n`However, the trick in identifying double pointer. Passing single pointer is as good as pass-by-value, and we will pass the same pointer again and again. We need to pass the address of head pointer for reflecting the changes in parent recursive calls.`\r\n  \r\n*******************\r\n####\tproblem-9: Given a linked list which is sorted, how will you insert in sorted way;\r\n*******************\r\n####### Algorithm:  \r\n*Let input linked list is sorted in increasing order.*  \r\n\r\n1. If Linked list is empty then make the node as head and return it.\r\n2. If value of the node to be inserted is smaller than value of head node, \r\n    then insert the node at start and make it head.\r\n3. In a loop, find the appropriate node after which the input node (let 9) is\r\n    to be inserted. To find the appropriate node start from head, keep moving \r\n    until you reach a node GN (10 in the below diagram) who's value is \r\n    greater than the input node. The node just before GN is the appropriate\r\n    node (7).\r\n4. Insert the node (9) after the appropriate node (7) found in step 3.  \r\n\r\n\r\n*******************\r\n####\tproblem-10: Remove duplicates from a sorted linked list.\r\n*******************\r\n*Write a removeDuplicates() function which takes a list sorted linked list and deletes any duplicate nodes from the list. The list should only be traversed once.*  \r\n\r\n`For example if the linked list is 11->11->11->21->43->43->60 ,`  \r\n`then removeDuplicates() should convert the list to 11->21->43->60.`  \r\n  \r\n\r\n#######\tAlgorithm:\r\n1. Traverse the list from the head (or start) node. \r\n2. While traversing, Compare each node with its next node. \r\n3. If data of next node is same as current node then delete the next node. \r\n4. Before we delete a node, we need to store next pointer of the node\r\n  \r\n*******************\r\n####\tproblem-11: Remove duplicates from an unsorted linked list.\r\n*******************\r\n*Write a removeDuplicates() function which takes a list and deletes any* \r\n*duplicate nodes from the list. The list is not sorted.*  \r\n\r\n######\tMethod-1: Using two loops; (trivial)\r\n- This is the simple way where two loops are used.  \r\n- Outer loop is used to pick the elements one by one and inner loop compares the picked element with rest of the elements.  \r\n\r\n######\tMethod-2: Use Sorting; (After Sorting, it becomes the question: problem-10)\r\n*In general, Merge Sort is the best suited sorting algorithm for sorting linked lists efficiently.*\r\n1. Sort the elements using Merge Sort. We will soon be writing a post about sorting a linked list. O(nLogn)\r\n2. Remove duplicates in linear time using the algorithm for removing duplicates in sorted Linked List. O(n)  \r\n  \r\n  *Please note that this method doesn’t preserve the original order of elements.*  \r\n  **Time Complexity: O(NLogN)**\r\n   \r\n######\tMethod-3: Use Hashing (trivial)\r\n1. We traverse the link list from head to end. \r\n2. For every newly encountered element, we check whether it is in the hash table: \r\n3. If yes, we remove it; otherwise we put it in the hash table.  \r\n\r\n**Time Complexity: O(n) on average (assuming that hash table access time is O(1) on average).**\r\n**Space Complexity: O(n)**  \r\n\r\n*******************\r\n####\tproblem-12: Print alternate nodes in a linked list from head to end and then from end to head;\r\n*******************  \r\nWrite a function that takes a linked list and then prints the alternate nodes from head to end and  \r\nthen prints the alternating nodes from end to head.  \r\n*For eg: if the linked list is: 1-->2-->3-->4-->5, then the function should print: 1 3 5 5 3 1*  \r\n  \r\n*******************\r\n####\tproblem-13: Move last element to front of a given Linked List\r\n*******************\r\nWrite a function that moves last element to front in a given Singly Linked List.  \r\n*For example, if the given Linked List is 1->2->3->4->5, then the function should change the list to 5->1->2->3->4.*\r\n  \r\n\r\n#######\tAlgorithm:  \r\n\tTraverse the list till last node. Use two pointers: one to store the address of last node and other for address of second last node. After the end of loop do following operations.  \r\n\t\r\n\ti) Make second last as last (secLast->next = NULL).\r\n\tii) Set next of last as head (last->next = *head_ref).\r\n\tiii) Make last as head ( *head_ref = last)  \r\n\t\r\n*******************\r\n####\tproblem-14: Pairwise swap elements of a given linked list\r\n*******************\r\nGiven a singly linked list, write a function to swap elements pairwise.  \r\n*For example, if the linked list is 1->2->3->4->5 then the function should change it to 2->1->4->3->5,*  \r\n*and if the linked list is 1->2->3->4->5->6 then the function should change it to 2->1->4->3->6->5.* \r\n\r\n######\tMETHOD 1: Iterative\r\nStart from the head node and traverse the list. While traversing swap data of each node with its next node’s data.  \r\n**Time complexity: O(n)**  \r\n\r\n######\tMETHOD 2: Recursive\r\n*If there are 2 or more than 2 nodes in Linked List then swap the first two nodes and recursively call for rest of the list.*  \r\n**Time complexity: O(n)**  \r\n \r\n######\tMETHOD 3: Changing the links of the nodes\r\n*Up till now we were only swapping the data of the nodes, But we will now actually swap the entire node by changing the links.*  \r\n**Time Complexity: O(n)**  \r\n\r\n\r\n*******************\r\n####\tproblem-15: Create a new linked list containing the elements(in sorted order) by having \r\n####\tintersection from 2 already sorted lists;\r\n*******************  \r\nGiven two lists sorted in increasing order, create and return a new list representing the intersection of the two lists.  \r\nThe new list should be made with its own memory — the original lists should not be changed.  \r\n\r\n*For example, let the first linked list be 1->2->3->4->6 and second linked list be 2->4->6->8,*  \r\n*then your function should create and return a third list as 2->4->6.*  \r\n\r\n######\tMethod 1: Iterative\r\nThis solution is structurally very similar to the above, but it avoids using a dummy node,  \r\nInstead, it maintains a struct node** pointer, lastPtrRef, that always points to the last pointer of the result list.  \r\nThis solves the same case that the dummy node did — dealing with the result list when it is empty.  \r\nIf you are trying to build up a list at its tail, either the dummy node or the struct node** “reference” strategy can be used.  \r\n**Time Complexity: O(m+n) where m and n are number of nodes in first and second linked lists respectively.**  \r\n\r\n\r\n\r\n######\tMethod 2: Recursive\r\n**Time Complexity: O(m+n) where m and n are number of nodes in first and second linked lists respectively. ** \r\n  \r\n  \r\n*******************\r\n####\tproblem-16: Delete alternate nodes of a Linked List \r\n*******************\r\nGiven a Singly Linked List, starting from the second node delete all alternate nodes of it.  \r\n*For example, if the given linked list is 1->2->3->4->5 then your function should convert it to 1->3->5,*  \r\n*and if the given linked list is 1->2->3->4 then convert it to 1->3.*  \r\n\r\n######\tMethod 1: Iterative; *Time complexity: O(n)*\r\n\t\r\n######\tMethod 2: Recursive; *Time complexity: O(n)*\r\n\r\n*******************\t\r\n####\tproblem-17: Alternating split of a given Singly Linked List\r\n*******************\r\nWrite a function AlternatingSplit() that takes one list and divides up its nodes to make two smaller lists ‘a’ and ‘b’.  \r\nThe sublists should be made from alternating elements in the original list.  \r\n*So if the original list is 0->1->0->1->0->1 then one sublist should be 0->0->0 and the other should be 1->1->1.*  \r\n\r\n######\tMethod 1: Simple Iterative Solution\r\nJust keep on traversing the linked-list and keep on putting alternate elements into 2 different linked-lists.\r\nBy the time you will reach the end of the linked-list you would be done.!! ie; have 2 different linked-lists each containing alternate elements of the original linked-list;\r\n\r\n######\tMethod 2: Simple Iteration Only, but space efficient, alters the original list\r\nWhile iterating the nodes of the linked-list , keep on removing the alternate nodes form the original linked-list and add them to the newer linked-list.\r\nBy the time , the iteration finishes, you will have one 2 linked list one the original one and second the new one that you created, both containing the alternate elements of the original linked-list. \r\n\r\n######\tMethod 3: Recursive Approach, space efficient, But , alters the original list  \r\n\t  \r\n\t    \r\n\t    \r\n*******************\t\r\n####\tproblem-18: Merging two linked lists at alternate positions\r\n*******************\r\nGiven 2 linked lists , merge them to a single linked-list such that each alternate node actually belongs to the same linked-list;  If second link list has extra nodes, print them as well.  \r\nExample:\r\n\t*5 - -> 10 - -> 15 - -> 20 - ->25 - -> null* \r\n\t*3 - -> 6 - ->9 - -> 12 - ->15 - ->18-->21--> null*\r\n\r\nOutput :\r\n\t*5 - -> 3 - -> 10 - -> 6 - ->15 - -> 9 - -> 20 - -> 12 - -> 25 - ->15 - -> null*\r\n\t*Remaining List : 18-->21-->null*\r\n\r\n\r\n\r\n*******************\t\r\n####\tproblem-19: Merging two sorted linked lists\r\n*******************\r\nGiven 2 linked lists already sorted individually,Now try to merge them to form a single sorted linked-list.\r\nWrite a SortedMerge() function that takes two lists, each of which is sorted in increasing order, and merges the two together into one list which is in increasing order. SortedMerge() should return the new list. The new list should be made by splicing\r\ntogether the nodes of the first two lists.  \r\n\t*For eg: lnkLst1= 1-->5-->8-->17-->25 and lnkLst2= -10-->2-->7-->13-->21-->30*\r\n\t*Then the final sorted list should be: -10-->1-->2-->5-->7-->8-->13-->17-->21-->25-->30*\r\n\r\n**There are many cases to deal with: either ‘a’ or ‘b’ may be empty, during processing either ‘a’ or ‘b’ may run out first, and finally there’s the problem of starting the result list empty, and building it up while going through ‘a’ and ‘b’.**\r\n\r\n######\tMethod 1: Iterative (Time Complexity O(m+n) )\r\n\t1. create a new node say result\r\n\t2. navigate through both the linked lists at the same time, starting from head\r\n\t3. compare the first node values of both the linked lists\r\n\t4. which ever is smaller, add it to the result node\r\n\t5. move the head pointer of the linked list whose value was smaller\r\n\t6. again compare the node values\r\n\t7. keep doing until one list gets over\r\n\t8. copy the rest of the nodes of unfinished list to the result \r\n\t\r\n\t\r\n######\tMethod 2: Recursive (Time Complexity O(m+n))\r\n\t**Base Case :**\r\n\tIf List A gets fin­ished , return List B.  \r\n\t\r\n\tIf List B gets fin­ished, return List A.  \r\n\t**Steps: ** \r\n\t1. Cre­ate a result node and ini­tial­ize it as NULL\r\n\t2. Check which node (List A or List B) has a smaller value.\r\n\t3. Whichever is smaller, add it to the result node.\r\n\t4. Make recur­sive call and add the return node as result.next\r\n\r\n******************* \r\n####  problem-20: Swap Every Kth Node in a LinkedList\r\n*******************\r\nGiven a linked list, swap every kth node in that.  \r\nIf at the end of the list remain­ing nodes are less than k, leave them untouched.  \r\n\r\n  Example:\r\n  *Input: A linked list, A num­ber k.*\r\n  *Input : ->1->2->3->4->5->6->7->8->9->10 , K = 4*\r\n  *Output: ->4->2->3->1->8->6->7->5->9->10*\r\n\r\n**Approach:**\r\n  1. Take 3 Point­ers, ptrOne, ptrTwo and ptrTwo_prev.\r\n  2. ptrOne and ptrTwo_prev points at head node.\r\n  3. ptrTwo points at next node of ptrTwo_prev.\r\n  4. Move the ptrTwo and ptrTwo_prev k-2 times, since we need one pointer each at both ends for swap­ping so move point­ers only k-2 times.\r\n  5. Cre­ate another pointer , New­Head and point it to ptrTwo.next.\r\n  6. Now we have ptrOne at head and ptrTwo at kth posi­tion, swap them with the help of ptrTwo_prev.\r\n  7. This func­tion will returns the head.\r\n  8. Now make a recursive call with newHead: ptrOne.next = reverseNodes(newHead, k);  \r\n\r\n  \r\n******************* \r\n####  problem-21: Swap Every Kth Node in a LinkedList with (N-k)th node;\r\n  ie; Swap kth node from head, with the kth node from end(in case both are same, do nothing)\r\n*******************\r\n Given a Linked List and a number k, Swap Kth Node from the front with the Kth Node from the End\r\nExample:\r\n*->10->20->30->40->50->60->70*\r\n\r\n*Swapping 1 Node from the Front and from the End*\r\n*->70->20->30->40->50->60->10*\r\n\r\n*Swapping 2 Node from the Front and from the End*\r\n*->70->60->30->40->50->20->10*\r\n\r\n*Swapping 3 Node from the Front and from the End*\r\n*->70->60->50->40->30->20->10*\r\n\r\n*k = 4, Nodes are same from front and at the end, no swapping*\r\n*->70->60->50->40->30->20->10*\r\n\r\n*Swapping 5 Node from the Front and from the End*\r\n*->70->60->30->40->50->20->10*\r\n\r\n*Swapping 6 Node from the Front and from the End*\r\n*->70->20->30->40->50->60->10*\r\n\r\n*Swapping 7 Node from the Front and from the End*\r\n*->10->20->30->40->50->60->70*\r\n\r\n*INVALID NUMBER, No Swapping, k>length of list*\r\n*->10->20->30->40->50->60->70*\r\n\r\n**Approach:**\r\n  1. Find the length of the list, say it is ‘Len’.  \r\n  2. If k>Len, No Swapping.   \r\n  3. If kth node from the front and the end are same (2*k-1=Len), No Swapping.   \r\n  4. If above two steps are not true then we need swap­ping of the elements.   \r\n  5. Take a pointer left, move it by k nodes. Keep track of node prior to left( call it as left_prev, we need it for the swapping).   \r\n  6. Set left_prev = null if k=1.   \r\n  7. Take a pointer right, move it by len-k+1 nodes(it will be the kth node from the end). Keep track of node prior to left( call it as right_prev, we need it for the swapping).   \r\n  8. Set right_prev = null if k=Len.   \r\n  9. If left_prev!=NULL means left node is not the first node, so make left_prev will point to right   \r\n  10. If right_prev!=NULL means right node is not the first node, so right_prev will point to left node.   \r\n  11. Now just swap the next and right.next to com­plete the swapping.    \r\n\r\n*NOTE:We need to change the head of list if k =1 (head = right) or k = len (head = left).*\r\n\r\n******************* \r\n####  problem-22: Delete X Nodes After Y Nodes In a Linked List\r\n*******************\r\nGiven a Linked List and x and y. Delete x number of nodes after y nodes from the start.\r\n*Example:*\r\n*->10->20->30->40->50->60->70->80->90->100->110->120*\r\n*Deleted 4 Nodes after 5 Nodes*\r\n*->10->20->30->40->50->100->110->120*\r\n\r\n**Approach:**\r\n  1.  need two pointers.\r\n  2. One pointer at one node prior to the nodes to be deleted. ( Move it by y start­ing from the head).\r\n  3. Another pointer at one node after to the nodes to be deleted. (Move it by x start­ing from the y, as per pre­vi­ous step).\r\n  4. Then Just link these two nodes.\r\n\r\n\r\n******************* \r\n####  problem-23: Add 2 numbers represented by the linked lists, in reverse order; \r\n  The result should be represented by the linked list(reverse order)\r\n*******************\r\n*Objective: Two numbers represented by a linked list where each node con­tains single digit.* \r\n*The dig­its are stored in REVERSE order, means head is point­ing to the first digit of the number.*\r\n\r\n`Input: Two numbers represented by Linked Lists`\r\n`Out­put: Addition of two numbers rep­re­sented by a Linked List.`\r\n\r\n*Example:*\r\n*First Number in REVERSE order: 5957*\r\n*Second Number in REVERSE order : 59*\r\n*Addition in REVERSE order : 0967*\r\n*Actual Result in FORWARD ORDER : 9670*\r\n\r\n**Approach:**\r\n1. Take a vari­able int carry =0.     \r\n2. Initialize Node newHead = null; and Node curr = null.    \r\n3. newHead will be the starting node of our result linked list and curr node will the reference to the current node on which we are working in our result linked list.    \r\n4. Navigate Both the lists simultaneously taking one node at a time.    \r\n5. Add the data of nodes and carry , say you call this as total.    \r\n6. Check if total >=10, if yes put carry =1 and total=total-10.    \r\n7. create a new node with value total, say you call it as Node ‘n’.   \r\n8. check if newHead is null, if yes then and assign ‘n’ to newHead. Now our starting node of result linked list is fixed.   \r\n9. if newHead is not null then add ‘n’ to the result linked list with the help of newHead and curr.   \r\n10. Now repeat steps 4 to 9 till any one of the list gets over( considering both the list has different length, if both list has the same length then both lists gets over at the same time, you will not need step 11).   \r\n11. Now navigate the list ( whichever is remain­ing) and add it to the result list. (take care of the carry, see Exam­ple). You can avoid this step by making sure that both the list has the same length adding 0 at the end of the shorter list , to see the similar implementation click here.    \r\n12. At the End check the carry, if it is not 0, create a new node with value 1 and add it to the result linked list.       \r\n  \r\n  \r\n  \r\n******************* \r\n####  problem-24: Add 2 numbers represented by the linked lists, in forward order; \r\n  The result should be represented by the linked list(forward order)\r\n*******************\r\n\r\n*Objective: Two num­bers represented by a linked list, where each node contains single digit. The digits are stored in* *Forward order, means head is pointing to the last digit of the number.*\r\n\r\n`Input: Two num­bers represented by Linked Lists`\r\n`Output: Addition of two numbers represented by a Linked List.`\r\n\r\n*Example:*\r\n*First Number : 1007*\r\n*Second Number : 93*\r\n*Addition : 1100*  \r\n\r\n**Approach:**\r\n1. Get the length of both the lists.   \r\n2. If lengths are not equal, make them equal by adding nodes with value 0 in front of shorter linked list.    \r\n3. Create a global variable carry=0.   \r\n4. Create a newHead = null;    \r\n5. newHead will be the starting node of our result linked list and curr node will the reference to the current node on which we are working in our result linked list.    \r\n6. Now using recursion travel in both the list till the end.    \r\n7. So now nodes are stores in a stack    \r\n8. Now while coming back, each node will pop out from the stack in reverse order    \r\n9. Take node data from both the lists add them along with carry.    \r\n10. if sum is >=10 , then make carry as 1 and create a new node with sum-10   \r\n11. Else just create a new Node with sum.   \r\n12. Add the newly created node to the result linked list with the help of newHead.    \r\n\r\n\r\n******************* \r\n####  problem-25:Given a Sorted Singly Linked List Array, Convert it into a Balanced Binary search Tree\r\n*******************\r\n*Objective: You have been given a sorted singly List, you need to con­vert it into balanced binary search tree.*\r\n\r\n\tWhy balanced binary tree is important:\r\n\tYou can also create first node as root and insert all other nodes to the right of the tree because List is in \t\t\tincreasing order but this constructed tree won’t be balanced tree, it wil be skwed tree and to perform \t\t\toperations on this tree will be O(n) not O(logn).\r\n\r\n`Input: An sorted Singly Linked List`\r\n`Out­put: Bal­anced Binary Tree`\r\n\r\n**Approach:**\r\n1. Say mid is the middle node in the linked list.   \r\n2. Recursively con­struct left sub­tree from start to mid-1   \r\n3. Make the middle node as root and assign the left sub­tree to it.   \r\n4. Recursively construct right subtree from mid+1 to end.   \r\n5. Assign the right sub­tree to root.   \r\n\r\n\r\n******************* \r\n####  problem-26:In a Binary Tree, Create Linked Lists of all the nodes at each depth\r\n*******************\r\n*Objective: Given a Binary tree create Linked Lists of all the nodes at each depth , say if the tree has height k then create k linked lists.*\r\n`Input: A binary tree`\r\n`Output: K linked lists if the height of tree is k. Each linked list will have all the nodes of each level.`\r\n\r\n**Approach:**\r\n\t--Recursion:\r\n1. Create a ArrayList of Linked List Nodes.   \r\n2. Do the level order traversal using queue(Breadth First Search). Click here to know about how to level order traversal.   \r\n3. For getting all the nodes at each level, before you take out a node from queue, store the size of the queue in a variable, say you call it as levelNodes.   \r\n4. Now while levelNodes>0, take out the nodes and print it and add their children into the queue. add these to a linked list   \r\n5. After this while loop put a line break and create a new linked list   \r\n\r\n\r\n******************* \r\n####  problem-27:Identical Linked Lists\r\n*******************\r\nTwo Linked Lists are identical when they have same data and arrangement of data is also same. \r\n*For example Linked lists a (1->2->3) and b(1->2->3) are identical.*\r\nWrite a function to check if the given two linked lists are identical.\r\n\r\n*Method 1 (Iterative)*\r\nTo identify if two lists are identical, we need to traverse both lists simultaneously, and while traversing we need to compare data.\r\n\r\n*Method 2 (Recursive)*\r\nRecursive solution code is much cleaner than the iterative code. \r\nYou probably wouldn’t want to use the recursive version for production code however, \r\nbecause it will use stack space which is proportional to the length of the lists\r\n\r\n*Time Complexity: O(n) for both iterative and recursive versions. n is the length of the smaller list among a and b.*\r\n\r\n\r\n******************* \r\n####  problem-28:Reverse a Linked List in groups of given size\r\n*******************\r\n*Given a linked list, write a function to reverse every k nodes (where k is an input to the function).*\r\n\r\n`Example:`\r\n`Inputs:  1->2->3->4->5->6->7->8->NULL and k = 3 `\r\n`Output:  3->2->1->6->5->4->8->7->NULL. `\r\n\r\n`Inputs:   1->2->3->4->5->6->7->80->NULL and k = 5`\r\n`Output:  5->4->3->2->1->8->7->6->NULL.` \r\n\r\n**Algorithm: reverse(head, k)**\r\n1. Reverse the first sub-list of size k. While reversing keep track of the next node and previous node. Let the pointer to the next node be next and pointer to the previous node be prev. See this post for reversing a linked list.   \r\n2. head->next = reverse(next, k) /* Recursively call for rest of the list and link the two sub-lists */   \r\n3. return prev /* prev becomes the new head of the list */   \r\n\r\n******************* \r\n####  problem-29: Sort a linked list of 0s, 1s and 2s\r\n*******************\r\nGiven a linked list of 0s, 1s and 2s, sort it.\r\n\r\n**Following steps can be used to sort the given linked list.**\r\n1. Traverse the list and count the number of 0s, 1s and 2s. Let the counts be n1, n2 and n3 respectively.   \r\n2. Traverse the list again, fill the first n1 nodes with 0, then n2 nodes with 1 and finally n3 nodes with 2.   \r\n\r\n******************* \r\n####  problem-30: Reverse alternate K nodes in a Singly Linked List\r\n*******************\r\nGiven a linked list, write a function to reverse every alternate k nodes (where k is an input to the function) in an efficient way. \r\nGive the complexity of your algorithm.\r\n\r\n`Example:`\r\n`Inputs:   1->2->3->4->5->6->7->8->9->NULL and k = 3`\r\n`Output:   3->2->1->4->5->6->9->8->7->NULL.` \r\n\r\n**Method 1 (Process 2k nodes and recursively call for rest of the list)** \r\nThis method is basically an extension of the method discussed in this post.\r\n\r\n**kAltReverse(struct node *head, int k) Time Complexity: O(n)**\r\n  1.  Reverse first k nodes.   \r\n  2.  In the modified list head points to the kth node.  So change next  \r\n       of head to (k+1)th node   \r\n  3.  Move the current pointer to skip next k nodes.   \r\n  4.  Call the kAltReverse() recursively for rest of the n - 2k nodes.   \r\n  5.  Return new head of the list.   \r\n  \r\n**Method 2 (Process k nodes and recursively call for rest of the list) **\r\nThe method 1 reverses the first k node and then moves the pointer to k nodes ahead. \r\nSo method 1 uses two while loops and processes 2k nodes in one recursive call.\r\nThis method processes only k nodes in a recursive call. \r\nIt uses a third bool parameter b which decides whether to reverse the k elements or simply move the pointer.\r\n\r\n**_kAltReverse(struct node *head, int k, bool b) Time Complexity: O(n)**\r\n  1.  If b is true, then reverse first k nodes.   \r\n  2.  If b is false, then move the pointer k nodes ahead.   \r\n  3.  Call the kAltReverse() recursively for rest of the n - k nodes and link\r\n       rest of the modified list with end of first k nodes.     \r\n  4.  Return new head of the list.      \r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}